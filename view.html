<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>선사 예술가</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />

    <style>
      /* 초기화 */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
        /* 스크롤 튕김 방지 */
        overscroll-behavior: none;
      }

      .slider {
        position: relative;
        width: 100%;

        /* [핵심 1] svh: 툴바/주소창이 다 나와있을 때의 '작은 화면' 기준 높이 */
        height: 100vh; /* 구형 브라우저용 */
        height: 100svh; /* 최신 브라우저용 (툴바 제외 높이) */

        overflow: hidden;
        touch-action: none;

        /* [핵심 2] 슬라이더 내부 요소들이 홈바에 닿지 않게 아래쪽 쿠션(패딩)을 줌 */
        /* padding-bottom: env(safe-area-inset-bottom); */
      }

      .slides {
        display: flex;
        width: 100%;
        height: 100%;
        transition: transform 0.35s ease;
        will-change: transform;
      }

      .slide {
        flex: 0 0 100%;
        width: 100%;
        height: 100%;

        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        overflow: hidden;
      }

      .slide img {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
        pointer-events: none;
        transition: transform 0.05s linear;
      }

      /* 페이지 정보 */
      .indicator {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);

        /* [핵심 3] max 함수: 홈바 영역(env)과 30px 중 '더 큰 값'을 선택 */
        /* 즉, 홈바가 있든 없든 최소 30px 이상은 무조건 띄움 */
        /* bottom: max(30px, env(safe-area-inset-bottom)); */
        bottom: calc(60px + env(safe-area-inset-bottom));

        color: #fff;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.4);
        padding: 6px 14px;
        border-radius: 20px;
        font-family: system-ui, -apple-system, sans-serif;
        opacity: 1;
        transition: opacity 0.3s ease;
        z-index: 100;
      }

      .indicator.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 16px;
        font-family: sans-serif;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="slider" id="slider">
      <div class="slides" id="slides"></div>
      <div class="indicator" id="indicator">0 / 0</div>
      <div class="message" id="message" style="display: none"></div>
    </div>

    <script>
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get("id") || "1";
      const countParam = params.get("count") || "1";

      const pagePrefixNumber = parseInt(idParam, 10) || 1;
      let imageCount = parseInt(countParam, 10);
      if (!imageCount || imageCount < 1) imageCount = 1;

      const imageFolder = "images";
      const imagePrefix = `${pagePrefixNumber}_`;
      const imageExt = ".jpg";

      const slidesContainer = document.getElementById("slides");
      const indicator = document.getElementById("indicator");
      const messageEl = document.getElementById("message");
      const slider = document.getElementById("slider");

      const images = [];
      for (let i = 1; i <= imageCount; i++) {
        images.push(`${imageFolder}/${imagePrefix}${i}${imageExt}`);
      }

      let currentIndex = 0;
      let total = images.length;

      // indicator 자동 숨김
      let indicatorHideTimeout = null;
      function showIndicatorTemporarily() {
        indicator.classList.remove("hidden");
        if (indicatorHideTimeout) {
          clearTimeout(indicatorHideTimeout);
        }
        indicatorHideTimeout = setTimeout(() => {
          indicator.classList.add("hidden");
        }, 2000);
      }

      // 줌 / 팬 상태
      let scale = 1;
      const MIN_SCALE = 1;
      const MAX_SCALE = 4;
      let translateX = 0;
      let translateY = 0;
      let isPinching = false;
      let initialPinchDistance = 0;
      let initialScale = 1;
      let lastMidX = 0;
      let lastMidY = 0;
      let isDragging = false;
      let isPanning = false;
      let startX = 0;
      let panPrevX = 0;
      let panPrevY = 0;
      const SWIPE_THRESHOLD = 50;

      function getSlides() {
        return document.getElementsByClassName("slide");
      }

      function applyTransform() {
        const slides = getSlides();
        for (let i = 0; i < slides.length; i++) {
          const img = slides[i].querySelector("img");
          if (!img) continue;
          if (i === currentIndex) {
            img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
          } else {
            img.style.transform = "translate(0px, 0px) scale(1)";
          }
        }
      }

      function clampPanForScale(newScale) {
        const slides = getSlides();
        const slide = slides[currentIndex];
        if (!slide) return;
        const img = slide.querySelector("img");
        if (!img) return;

        const rect = img.getBoundingClientRect();
        const vw = slider.clientWidth;
        const vh = slider.clientHeight;

        const prevScale = scale || 1;
        const baseW = rect.width / prevScale;
        const baseH = rect.height / prevScale;

        const scaledW = baseW * newScale;
        const scaledH = baseH * newScale;

        if (scaledW <= vw) {
          translateX = 0;
        } else {
          const maxOffsetX = (scaledW - vw) / 2;
          if (translateX > maxOffsetX) translateX = maxOffsetX;
          if (translateX < -maxOffsetX) translateX = -maxOffsetX;
        }

        if (scaledH <= vh) {
          translateY = 0;
        } else {
          const maxOffsetY = (scaledH - vh) / 2;
          if (translateY > maxOffsetY) translateY = maxOffsetY;
          if (translateY < -maxOffsetY) translateY = -maxOffsetY;
        }
      }

      function resetZoom() {
        scale = 1;
        translateX = 0;
        translateY = 0;
        applyTransform();
      }

      function updateSlide() {
        if (total === 0) return;
        const offset = -currentIndex * 100;
        slidesContainer.style.transform = `translateX(${offset}%)`;
        indicator.textContent = `${currentIndex + 1} / ${total}`;
        resetZoom();
        showIndicatorTemporarily();
      }

      function buildSlides() {
        if (total === 0) {
          messageEl.style.display = "block";
          messageEl.textContent = "표시할 이미지가 없습니다.";
          indicator.textContent = "0 / 0";
          return;
        }
        images.forEach((src) => {
          const slide = document.createElement("div");
          slide.className = "slide";
          const img = document.createElement("img");
          img.src = src;
          img.alt = src;
          img.loading = "lazy";
          slide.appendChild(img);
          slidesContainer.appendChild(slide);
        });
        updateSlide();
        attachEvents();
      }

      function distance(t1, t2) {
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
      }

      function midpoint(t1, t2) {
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2,
        };
      }

      function attachEvents() {
        // [충돌 방지용 플래그]
        // 터치 장치에서 마우스 이벤트가 중복 실행되는 것을 막기 위한 변수입니다.
        let isTouch = false;

        // =========================================
        // 1. 모바일 터치 이벤트 (Touch)
        // =========================================
        slider.addEventListener(
          "touchstart",
          (e) => {
            if (total === 0) return;

            // 터치가 시작되면 플래그를 세웁니다.
            isTouch = true;

            if (e.touches.length === 2) {
              // 핀치 줌 시작
              isPinching = true;
              isDragging = false;
              isPanning = false;

              const [t1, t2] = e.touches;
              initialPinchDistance = distance(t1, t2);
              initialScale = scale;
              const mid = midpoint(t1, t2);
              lastMidX = mid.x;
              lastMidY = mid.y;
            } else if (e.touches.length === 1) {
              // 스와이프/팬 시작
              const touch = e.touches[0];
              startX = touch.clientX;
              isDragging = true;
              isPanning = false;
              panPrevX = touch.clientX;
              panPrevY = touch.clientY;
            }
          },
          { passive: false }
        );

        slider.addEventListener(
          "touchmove",
          (e) => {
            if (total === 0) return;

            if (e.touches.length === 2) {
              // 핀치 줌 동작
              e.preventDefault();
              isPinching = true;
              const [t1, t2] = e.touches;
              const dist = distance(t1, t2);
              const mid = midpoint(t1, t2);

              const rawScale = initialScale * (dist / initialPinchDistance);
              let newScale = rawScale;
              if (newScale < MIN_SCALE) newScale = MIN_SCALE;
              if (newScale > MAX_SCALE) newScale = MAX_SCALE;

              if (initialScale <= MIN_SCALE && rawScale <= MIN_SCALE) {
                scale = MIN_SCALE;
                translateX = 0;
                translateY = 0;
                applyTransform();
                return;
              }

              if (newScale > MIN_SCALE) {
                const dx = mid.x - lastMidX;
                const dy = mid.y - lastMidY;
                translateX += dx;
                translateY += dy;
              } else {
                translateX = 0;
                translateY = 0;
              }

              lastMidX = mid.x;
              lastMidY = mid.y;
              clampPanForScale(newScale);
              scale = newScale;
              applyTransform();
            } else if (e.touches.length === 1) {
              // 한 손가락 이동
              const touch = e.touches[0];
              if (scale > 1) {
                e.preventDefault();
                const dx = touch.clientX - panPrevX;
                const dy = touch.clientY - panPrevY;
                translateX += dx;
                translateY += dy;
                panPrevX = touch.clientX;
                panPrevY = touch.clientY;
                isPanning = true;
                clampPanForScale(scale);
                applyTransform();
              }
            }
          },
          { passive: false }
        );

        slider.addEventListener(
          "touchend",
          (e) => {
            if (total === 0) return;

            // 터치가 끝난 후 0.5초 뒤에 플래그 해제 (유령 마우스 방지)
            setTimeout(() => {
              isTouch = false;
            }, 500);

            if (isPinching) {
              if (e.touches.length >= 1) {
                isPinching = false;
                return;
              } else {
                isPinching = false;
              }
            }

            if (!isDragging) return;

            if (scale > 1 || isPanning) {
              isDragging = false;
              isPanning = false;
              return;
            }

            const touch = e.changedTouches[0];
            const endX = touch.clientX;
            const diffX = endX - startX;

            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
              if (diffX < 0 && currentIndex < total - 1) {
                currentIndex++;
              } else if (diffX > 0 && currentIndex > 0) {
                currentIndex--;
              }
              updateSlide();
            }

            isDragging = false;
            isPanning = false;
          },
          { passive: false }
        );

        // =========================================
        // 2. PC 마우스 이벤트 (Mouse) - 추가된 부분
        // =========================================

        // 마우스 클릭 (mousedown)
        slider.addEventListener("mousedown", (e) => {
          // 터치 중이면 마우스 이벤트 무시!
          if (isTouch) return;
          if (total === 0) return;

          e.preventDefault(); // 이미지 드래그 방지

          startX = e.clientX;
          isDragging = true;
          isPanning = false;
          panPrevX = e.clientX;
          panPrevY = e.clientY;
        });

        // 마우스 이동 (mousemove)
        slider.addEventListener("mousemove", (e) => {
          if (isTouch) return;
          if (!isDragging) return;

          // 줌 상태일 때 이동 (Panning)
          if (scale > 1) {
            e.preventDefault();
            const dx = e.clientX - panPrevX;
            const dy = e.clientY - panPrevY;

            translateX += dx;
            translateY += dy;

            panPrevX = e.clientX;
            panPrevY = e.clientY;
            isPanning = true;

            clampPanForScale(scale);
            applyTransform();
          }
        });

        // 마우스 뗌 (mouseup) 및 나감 (mouseleave) 공통 처리
        const stopMouseDrag = (e) => {
          if (isTouch) return;
          if (!isDragging) return;

          // 줌 상태에서 이동 중이었다면 스와이프 안 함
          if (scale > 1 || isPanning) {
            isDragging = false;
            isPanning = false;
            return;
          }

          // 스와이프 판정
          const endX = e.clientX;
          const diffX = endX - startX;

          if (Math.abs(diffX) > SWIPE_THRESHOLD) {
            if (diffX < 0 && currentIndex < total - 1) {
              currentIndex++;
            } else if (diffX > 0 && currentIndex > 0) {
              currentIndex--;
            }
            updateSlide();
          }

          isDragging = false;
          isPanning = false;
        };

        slider.addEventListener("mouseup", stopMouseDrag);
        slider.addEventListener("mouseleave", stopMouseDrag);
      }

      buildSlides();
    </script>
  </body>
</html>
