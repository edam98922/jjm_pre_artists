<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>선사 예술가</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />

    <style>
      /* 초기화 */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden; /* 스크롤 방지 */
        background: #000;
        position: fixed; /* 화면 고정 */
        left: 0;
        top: 0;
      }

      .slider {
        position: relative;
        width: 100%;
        /* [핵심] 높이는 JS로 제어하므로 일단 100%로 둡니다 */
        height: 100%;
        overflow: hidden;
        touch-action: none;
      }

      .slides {
        display: flex;
        width: 100%;
        height: 100%;
        transition: transform 0.35s ease;
        will-change: transform;
      }

      .slide {
        flex: 0 0 100%;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        overflow: hidden;
      }

      .slide img {
        /* 이미지가 화면을 절대 넘어가지 않게 제한 */
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
        pointer-events: none;
        transition: transform 0.05s linear;
      }

      /* 페이지 정보 */
      .indicator {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);

        /* [중요 수정] 홈바/메뉴바를 피하기 위해 바닥에서 30px + 안전구역만큼 띄움 */
        bottom: calc(30px + env(safe-area-inset-bottom));

        color: #fff;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.4);
        padding: 6px 14px;
        border-radius: 20px;
        font-family: system-ui, -apple-system, sans-serif;
        opacity: 1;
        transition: opacity 0.3s ease;
        z-index: 100;
      }

      .indicator.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 16px;
        font-family: sans-serif;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="slider" id="slider">
      <div class="slides" id="slides"></div>
      <div class="indicator" id="indicator">0 / 0</div>
      <div class="message" id="message" style="display: none"></div>
    </div>

    <script>
      // ===== [핵심] 모바일 브라우저 높이 계산 (100vh 버그 해결) =====
      function setScreenSize() {
        // window.innerHeight는 주소창을 뺀 '진짜 보이는 높이'를 줍니다.
        const vh = window.innerHeight;
        // 슬라이더 높이를 픽셀 단위로 강제 고정합니다.
        document.getElementById("slider").style.height = `${vh}px`;
      }

      // 처음 로드될 때 실행
      setScreenSize();

      // 화면 회전하거나 사이즈 바뀌면 다시 계산
      window.addEventListener("resize", setScreenSize);

      // ===== 기존 로직 시작 =====
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get("id") || "1";
      const countParam = params.get("count") || "1";

      const pagePrefixNumber = parseInt(idParam, 10) || 1;
      let imageCount = parseInt(countParam, 10);
      if (!imageCount || imageCount < 1) imageCount = 1;

      const imageFolder = "images";
      const imagePrefix = `${pagePrefixNumber}_`;
      const imageExt = ".jpg";

      const slidesContainer = document.getElementById("slides");
      const indicator = document.getElementById("indicator");
      const messageEl = document.getElementById("message");
      const slider = document.getElementById("slider");

      const images = [];
      for (let i = 1; i <= imageCount; i++) {
        images.push(`${imageFolder}/${imagePrefix}${i}${imageExt}`);
      }

      let currentIndex = 0;
      let total = images.length;

      // indicator 자동 숨김
      let indicatorHideTimeout = null;
      function showIndicatorTemporarily() {
        indicator.classList.remove("hidden");
        if (indicatorHideTimeout) {
          clearTimeout(indicatorHideTimeout);
        }
        indicatorHideTimeout = setTimeout(() => {
          indicator.classList.add("hidden");
        }, 2000);
      }

      // 줌 / 팬 상태
      let scale = 1;
      const MIN_SCALE = 1;
      const MAX_SCALE = 4;
      let translateX = 0;
      let translateY = 0;
      let isPinching = false;
      let initialPinchDistance = 0;
      let initialScale = 1;
      let lastMidX = 0;
      let lastMidY = 0;
      let isDragging = false;
      let isPanning = false;
      let startX = 0;
      let panPrevX = 0;
      let panPrevY = 0;
      const SWIPE_THRESHOLD = 50;

      function getSlides() {
        return document.getElementsByClassName("slide");
      }

      function applyTransform() {
        const slides = getSlides();
        for (let i = 0; i < slides.length; i++) {
          const img = slides[i].querySelector("img");
          if (!img) continue;
          if (i === currentIndex) {
            img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
          } else {
            img.style.transform = "translate(0px, 0px) scale(1)";
          }
        }
      }

      function clampPanForScale(newScale) {
        const slides = getSlides();
        const slide = slides[currentIndex];
        if (!slide) return;
        const img = slide.querySelector("img");
        if (!img) return;

        const rect = img.getBoundingClientRect();
        const vw = slider.clientWidth;
        const vh = slider.clientHeight;

        const prevScale = scale || 1;
        const baseW = rect.width / prevScale;
        const baseH = rect.height / prevScale;

        const scaledW = baseW * newScale;
        const scaledH = baseH * newScale;

        if (scaledW <= vw) {
          translateX = 0;
        } else {
          const maxOffsetX = (scaledW - vw) / 2;
          if (translateX > maxOffsetX) translateX = maxOffsetX;
          if (translateX < -maxOffsetX) translateX = -maxOffsetX;
        }

        if (scaledH <= vh) {
          translateY = 0;
        } else {
          const maxOffsetY = (scaledH - vh) / 2;
          if (translateY > maxOffsetY) translateY = maxOffsetY;
          if (translateY < -maxOffsetY) translateY = -maxOffsetY;
        }
      }

      function resetZoom() {
        scale = 1;
        translateX = 0;
        translateY = 0;
        applyTransform();
      }

      function updateSlide() {
        if (total === 0) return;
        const offset = -currentIndex * 100;
        slidesContainer.style.transform = `translateX(${offset}%)`; // vw대신 %사용
        indicator.textContent = `${currentIndex + 1} / ${total}`;
        resetZoom();
        showIndicatorTemporarily();
      }

      function buildSlides() {
        if (total === 0) {
          messageEl.style.display = "block";
          messageEl.textContent = "표시할 이미지가 없습니다.";
          indicator.textContent = "0 / 0";
          return;
        }
        images.forEach((src) => {
          const slide = document.createElement("div");
          slide.className = "slide";
          const img = document.createElement("img");
          img.src = src;
          img.alt = src;
          img.loading = "lazy";
          slide.appendChild(img);
          slidesContainer.appendChild(slide);
        });
        updateSlide();
        attachEvents();
      }

      function distance(t1, t2) {
        const dx = t2.clientX - t1.clientX;
        const dy = t2.clientY - t1.clientY;
        return Math.hypot(dx, dy);
      }

      function midpoint(t1, t2) {
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2,
        };
      }

      function attachEvents() {
        slider.addEventListener(
          "touchstart",
          (e) => {
            if (total === 0) return;
            if (e.touches.length === 2) {
              isPinching = true;
              isDragging = false;
              isPanning = false;
              const [t1, t2] = e.touches;
              initialPinchDistance = distance(t1, t2);
              initialScale = scale;
              const mid = midpoint(t1, t2);
              lastMidX = mid.x;
              lastMidY = mid.y;
            } else if (e.touches.length === 1) {
              const touch = e.touches[0];
              startX = touch.clientX;
              isDragging = true;
              isPanning = false;
              panPrevX = touch.clientX;
              panPrevY = touch.clientY;
            }
          },
          { passive: false }
        );

        slider.addEventListener(
          "touchmove",
          (e) => {
            if (total === 0) return;
            if (e.touches.length === 2) {
              e.preventDefault();
              isPinching = true;
              const [t1, t2] = e.touches;
              const dist = distance(t1, t2);
              const mid = midpoint(t1, t2);
              const rawScale = initialScale * (dist / initialPinchDistance);
              let newScale = rawScale;
              if (newScale < MIN_SCALE) newScale = MIN_SCALE;
              if (newScale > MAX_SCALE) newScale = MAX_SCALE;

              if (initialScale <= MIN_SCALE && rawScale <= MIN_SCALE) {
                scale = MIN_SCALE;
                translateX = 0;
                translateY = 0;
                applyTransform();
                return;
              }
              if (newScale > MIN_SCALE) {
                const dx = mid.x - lastMidX;
                const dy = mid.y - lastMidY;
                translateX += dx;
                translateY += dy;
              } else {
                translateX = 0;
                translateY = 0;
              }
              lastMidX = mid.x;
              lastMidY = mid.y;
              clampPanForScale(newScale);
              scale = newScale;
              applyTransform();
            } else if (e.touches.length === 1) {
              const touch = e.touches[0];
              if (scale > 1) {
                e.preventDefault();
                const dx = touch.clientX - panPrevX;
                const dy = touch.clientY - panPrevY;
                translateX += dx;
                translateY += dy;
                panPrevX = touch.clientX;
                panPrevY = touch.clientY;
                isPanning = true;
                clampPanForScale(scale);
                applyTransform();
              }
            }
          },
          { passive: false }
        );

        slider.addEventListener(
          "touchend",
          (e) => {
            if (total === 0) return;
            if (isPinching) {
              if (e.touches.length >= 1) {
                isPinching = false;
                return;
              } else {
                isPinching = false;
              }
            }
            if (!isDragging) return;
            if (scale > 1 || isPanning) {
              isDragging = false;
              isPanning = false;
              return;
            }
            const touch = e.changedTouches[0];
            const endX = touch.clientX;
            const diffX = endX - startX;
            if (Math.abs(diffX) > SWIPE_THRESHOLD) {
              if (diffX < 0 && currentIndex < total - 1) {
                currentIndex++;
              } else if (diffX > 0 && currentIndex > 0) {
                currentIndex--;
              }
              updateSlide();
            }
            isDragging = false;
            isPanning = false;
          },
          { passive: false }
        );
      }

      buildSlides();
    </script>
  </body>
</html>
